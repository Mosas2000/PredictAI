# PredictionMarket Smart Contract

A Solidity 0.8.20 prediction market contract with TypeScript types generated by TypeChain.

## Contract Overview

The `PredictionMarket` contract allows:
- Owner to create binary prediction markets
- Users to bet on "Yes" or "No" outcomes
- Owner to resolve markets with winning outcomes
- Users to claim proportional winnings based on their bets

## Key Features

- **Market Management**: Only owner can create and resolve markets
- **Betting System**: Payable functions for Yes/No bets with tracking
- **Proportional Payouts**: Winners receive proportional share of total pool
- **Event Logging**: All major actions emit events
- **Error Handling**: Custom errors for gas-efficient failures
- **TypeScript Support**: Full TypeChain integration

## Contract Structure

### State Variables
- `owner`: Contract owner address
- `nextMarketId`: Auto-incrementing market ID counter
- `markets`: Mapping of market ID to Market struct
- `yesBets`/`noBets`: User bet amounts per market
- `hasClaimed`: Claim status tracking

### Market Struct
```solidity
struct Market {
    uint256 id;
    string question;
    uint256 totalYesBets;
    uint256 totalNoBets;
    bool resolved;
    bool winningOutcome; // true = yes wins, false = no wins
}
```

### Functions

#### Owner Functions
- `createMarket(string calldata question)` - Creates new market
- `resolveMarket(uint256 id, bool winningOutcome)` - Resolves market

#### User Functions
- `betYes(uint256 id)` - Bet on Yes outcome (payable)
- `betNo(uint256 id)` - Bet on No outcome (payable)
- `claim(uint256 id)` - Claim winnings after resolution

#### View Functions
- `getMarket(uint256 id)` - Returns market details
- `getUserBets(uint256 id, address user)` - Returns user's bet info

### Events
- `MarketCreated(uint256 indexed id, string question)`
- `BetPlaced(uint256 indexed id, address indexed bettor, bool outcome, uint256 amount)`
- `MarketResolved(uint256 indexed id, bool winningOutcome, uint256 totalYesBets, uint256 totalNoBets)`
- `WinningsClaimed(uint256 indexed id, address indexed user, uint256 payout)`

### Custom Errors
- `OnlyOwner()` - Unauthorized access
- `MarketDoesNotExist(uint256 id)` - Invalid market ID
- `MarketAlreadyResolved(uint256 id)` - Market already resolved
- `InvalidBetAmount()` - Zero bet amount
- `AlreadyClaimed(uint256 id, address user)` - Duplicate claim
- `NoWinnings(uint256 id, address user)` - No winnings to claim
- `CannotResolveWithoutBets(uint256 id)` - No bets in market
- `TransferFailed()` - ETH transfer failed

## TypeScript Types

The contract includes comprehensive TypeScript types via TypeChain:

### Market Types
```typescript
type MarketStruct = {
  id: BigNumberish;
  question: string;
  totalYesBets: BigNumberish;
  totalNoBets: BigNumberish;
  resolved: boolean;
  winningOutcome: boolean;
};
```

### Event Types
```typescript
type MarketCreatedEvent = TypedEvent<[BigNumber, string], MarketCreatedEventObject>;
type BetPlacedEvent = TypedEvent<[BigNumber, string, boolean, BigNumber], BetPlacedEventObject>;
type MarketResolvedEvent = TypedEvent<[BigNumber, boolean, BigNumber, BigNumber], MarketResolvedEventObject>;
type WinningsClaimedEvent = TypedEvent<[BigNumber, string, BigNumber], WinningsClaimedEventObject>;
```

### Contract Interface
Full ethers.js contract interface with:
- Function signatures and return types
- Event filters and listeners
- Call static, estimate gas, and populate transaction methods
- Factory deployment support

## Usage Example

```typescript
import { PredictionMarket, PredictionMarket__factory } from './typechain';

// Deploy contract
const factory = new PredictionMarket__factory(signer);
const contract = await factory.deploy();

// Create market
const tx = await contract.createMarket("Will ETH price exceed $3000 by end of year?");
const receipt = await tx.wait();
const marketId = receipt.events?.[0].args?.id;

// Place bets
await contract.betYes(marketId, { value: ethers.utils.parseEther("1.0") });
await contract.betNo(marketId, { value: ethers.utils.parseEther("0.5") });

// Resolve market (owner only)
await contract.resolveMarket(marketId, true);

// Claim winnings
await contract.claim(marketId);

// Listen to events
contract.on("MarketCreated", (id, question) => {
  console.log(`Market ${id} created: ${question}`);
});
```

## Security Considerations

- Uses checks-effects-interactions pattern
- Reentrancy protection via state updates before external calls
- Proper access control with owner-only functions
- Safe ETH transfers with failure handling
- Input validation for all functions

## Gas Optimization

- Custom errors instead of revert strings
- Efficient storage packing in structs
- Minimal external calls
- Optimized event emissions

## Testing

The project includes a comprehensive test suite covering all contract functionality:

### Test Coverage
- **Market Creation**: Creating markets, ID incrementation, authorization checks
- **Placing Bets**: Yes/No bets, multiple bets, validation checks
- **Market Resolution**: Resolving markets, authorization, edge cases
- **Claiming Winnings**: Payout calculations, multiple winners, error handling
- **Edge Cases**: Resolved markets, single winners, equal pools, small bets

### Running Tests

```bash
# Install dependencies (first time only)
npm install

# Run all tests
npm test

# Or directly with Hardhat
npx hardhat test

# Quick setup script (installs deps and runs tests)
./scripts/setup-tests.sh
```

### Test Structure
- Located in `test/PredictionMarket.test.ts`
- Uses Mocha test framework and Chai assertions
- Tests all contract functions and edge cases
- Validates event emissions and error conditions
- Tests with multiple user accounts and realistic scenarios

## Development

```bash
# Compile contract
npx hardhat compile

# Run tests
npx hardhat test

# Deploy to local network
npx hardhat run scripts/deploy.ts --network localhost
```

## License

MIT License